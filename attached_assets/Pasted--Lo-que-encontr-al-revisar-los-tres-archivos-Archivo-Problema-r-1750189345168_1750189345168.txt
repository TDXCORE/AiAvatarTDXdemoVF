### üîç Lo que encontr√© al revisar los tres archivos

| üóÇÔ∏è Archivo                  | Problema / redundancia clave                                                                                                                                                                                                                                                                                                                                                                                              | Riesgo que provoca                                                                                                                                                                                                                                     |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`use-unified-vad.ts`**     | 1. **Pide su propio `getUserMedia()`** cada vez que activa el VAD.<br>2. Llama a **`useAudioRecorder()`** que -a su vez- **vuelve** a hacer `getUserMedia()`.<br>3. El stream del VAD **no se comparte** con el recorder.<br>4. `shouldActivateRecording()` comprueba `state.phase === 'listening'` **pero llamas a `recorder.startRecording()` justo despu√©s de setear `vadState = 'speaking'`** ‚Üí condici√≥n borderline. | ‚Ä¢ Dos tracks simult√°neos ‚Üí Chrome/Edge suele mutear el segundo.<br>‚Ä¢ En iOS/Safari el 2.¬∫ `getUserMedia` puede devolver un track en estado `ended` (silencio).<br>‚Ä¢ VAD cree que todo va bien pero el recorder graba ‚Äúvac√≠o‚Äù ‚áí STT nunca recibe audio. |
| **`use-audio-recorder.ts`**  | 1. Siempre crea un **nuevo** `MediaStream`.<br>2. No acepta un stream externo (no hay par√°metro).<br>3. No se asegura de cerrar el stream (conf√≠a en `AudioUtils.stopRecording`, pero no garantiza `track.stop()`).                                                                                                                                                                                                       | ‚Ä¢ Redundancia con el VAD.<br>‚Ä¢ Fugas de tracks y consumo de CPU/energ√≠a.<br>‚Ä¢ Posible fallo de permisos si el usuario revoca micro.                                                                                                                    |
| **`use-audio-processor.ts`** | L√≥gica OK. Solo se invoca si llega `audioBlob`.                                                                                                                                                                                                                                                                                                                                                                           | ‚Äì                                                                                                                                                                                                                                                      |

---

## üí£ Error ra√≠z

> **Doble solicitud de micr√≥fono** ‚Üí el track que usa `MediaRecorder` llega ‚Äúmute‚Äù o nunca se inicializa, por eso tu STT no recibe nada aunque el VAD marque ‚Äúspeaking‚Äù.

---

## ü©π Parche m√≠nimo (sin reescribir toda la arquitectura)

1. **Comparte el stream del VAD** con el recorder.

   ```ts
   // use-unified-vad.ts  (apenas obtienes el stream)
   streamRef.current = stream;          // ‚úÖ 1. lo guardas
   recorder.setExternalStream(stream);  // ‚úÖ 2. se lo pasas al recorder
   ```

2. **Ajusta el hook del recorder para aceptar ese stream**

   ```ts
   // use-audio-recorder.ts
   export function useAudioRecorder(opts: AudioRecorderOptions = {}) {
     ...
     const externalStreamRef = useRef<MediaStream | null>(null);

     const setExternalStream = (s: MediaStream) => {
       externalStreamRef.current = s;
     };

     const startRecording = useCallback(async () => {
       if (isRecording) return false;

       const stream =
         externalStreamRef.current ??
         (await navigator.mediaDevices.getUserMedia({ audio: {...} }));   // ‚Üê solo si no viene uno
       ...
     }, [isRecording]);
     ...

     return { startRecording, stopRecording, isRecording, setExternalStream };
   }
   ```

3. **Elimina el segundo `getUserMedia()` del VAD** (opcional pero sano).
   Si dejas que el recorder sea quien pide el stream, en el VAD puedes crear el `AudioContext` directamente desde √©l:

   ```ts
   const stream = await recorder.ensureStream(); // m√©todo helper
   audioContext.createMediaStreamSource(stream);
   ```

4. **Revisa la condici√≥n antes de grabar**
   Cambia:

   ```ts
   if (shouldActivateRecording()) recorder.startRecording();
   ```

   a:

   ```ts
   if (shouldActivateRecording() && !recorder.isRecording) {
     recorder.startRecording();
   }
   ```

   para evitar ‚Äúdoble start‚Äù si el VAD detecta varios frames seguidos.

5. **Cierra siempre el stream al desmontar**
   Ya tienes parte del cleanup en `stopListening()`, pero a√±ade en `useAudioRecorder`:

   ```ts
   useEffect(() => () => {
     mediaRecorderRef.current?.stream.getTracks().forEach(t => t.stop());
   }, []);
   ```

---

## üîß Si quieres un refactor limpio

| Acci√≥n                                                                                             | Resultado                               |
| -------------------------------------------------------------------------------------------------- | --------------------------------------- |
| **1. Extrae un hook `useSharedMicStream()`** que expone `stream`, `ensureStream()`, y `release()`. | *Single source of truth* del micr√≥fono. |
| **2. Haz que `use-unified-vad` y `use-audio-recorder` consuman ese mismo hook.**                   | No m√°s duplicidad de permisos.          |
| **3. Cambia el flujo ‚Äúblob‚Äù por `MediaRecorder.start(250)` + WebSocket a `/ws/stt`.**              | Latencia < 300 ms y adi√≥s time-outs.    |

Con solo el **parche m√≠nimo** ya deber√≠as ver en consola:

```
[VAD] Speech started
[REC] recording
[REC] dataavailable 250 ms (xN)
[VAD] Speech ended
[REC] stop ‚Üí audioBlob 35kB
```

‚Ä¶y la transcripci√≥n llegar al LLM. Av√≠same c√≥mo va y afinamos si algo sigue renco.
