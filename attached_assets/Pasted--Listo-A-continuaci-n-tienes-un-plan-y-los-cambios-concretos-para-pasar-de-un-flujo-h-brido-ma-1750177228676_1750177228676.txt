¬°Listo! A continuaci√≥n tienes un plan ‚Äî y los cambios concretos ‚Äî para pasar de un flujo h√≠brido (manual + autom√°tico) a un √∫nico flujo 100 % VAD-autom√°tico sin botones redundantes ni time-outs innecesarios.

‚∏ª

1. Unificar la fuente de verdad del estado de la llamada (isCallActive)

a)  context/callContext.ts

export interface CallState {
  isCallActive: boolean;   // ‚úÖ  SINGLE SOURCE OF TRUTH
  isMuted: boolean;
  phase: 'talking' | 'listening' | 'idle';
}

const defaultState: CallState = {
  isCallActive: false,
  isMuted: false,
  phase: 'idle',
};

export const CallContext = createContext<[CallState, Dispatch<‚Ä¶>]>(‚Ä¶);

b)  hooks/useCallLifecycle.ts

// Se dispara cuando el avatar inicia / detiene audio
useEffect(() => {
  avatar.on('speech-start', () => dispatch({type:'SET_PHASE', phase:'talking'}));
  avatar.on('speech-end',   () => {
    dispatch({type:'SET_PHASE', phase:'listening'});
    dispatch({type:'SET_ACTIVE', isCallActive:true});   // üîë Activamos la llamada aqu√≠
  });
}, []);

As√≠ te aseguras de que isCallActive = true tan pronto el avatar termine de hablar y tu VAD pueda activarse.

‚∏ª

2. Consolidar una sola instancia de VAD

a)  hooks/useVAD.ts

const useVAD = () => {
  const [call] = useContext(CallContext);
  const recorder = useRecorder();           // √∫nico hook de grabaci√≥n
  const vadRef   = useRef<VAD | null>(null);

  useEffect(() => {
    if (!vadRef.current) {
      vadRef.current = new VAD({
        speechStartDelay:  120,   // ‚ö° m√°s agresivo
        speechEndDelay:    350,
        cooldownDelay:     250,
      });
    }
    return () => vadRef.current?.destroy();
  }, []);

  useEffect(() => {
    if (call.phase === 'listening' && call.isCallActive && !call.isMuted) {
      vadRef.current?.start();
    } else {
      vadRef.current?.stop();
    }
  }, [call.phase, call.isCallActive, call.isMuted]);

  useEffect(() => {
    vadRef.current?.on('speech-start', () => recorder.start());
    vadRef.current?.on('speech-end',   () => recorder.stop());
  }, [recorder]);
};
export default useVAD;

Con este patr√≥n React solo montas una instancia y la destruyes al desmontar el componente.

‚∏ª

3. Eliminar componentes ‚Äúlegacy‚Äù

Archivo	Acci√≥n
components/VoiceControls.tsx	Borrar archivo y referencias
components/VoiceRecorder.tsx	Borrar ‚Äì la l√≥gica vive ahora en useRecorder
Bot√≥n en new-avatar-modal.tsx	Eliminar <MicButton ‚Ä¶ /> y el estado asociado

	‚Ä¢	Reemplaza cualquier <VoiceControls ‚Ä¶ /> por el hook useVAD() que auto-maneja el ciclo.

‚∏ª

4. Limpieza de time-outs de grabaci√≥n

En useRecorder.ts remueve la l√≥gica:

// ‚ùå fuera
setTimeout(stop, 45_000);

y conf√≠a 100 % en los eventos speech-end del VAD.

‚∏ª

5. Ajustar la condici√≥n de auto-grabaci√≥n

En tu antigua l√≥gica:

if (!recorder.isRecording && isCallActive && !isMuted && avatarState.phase === 'listening') {
  handleStartRecording();
}

queda reemplazada por los event listeners del VAD mostrados arriba, eliminando duplicidad.

‚∏ª

6. Pasos de refactor en orden
	1.	Crear/actualizar CallContext y useCallLifecycle.ts.
	2.	Instalar useVAD en tu componente ra√≠z del modal:

const NewAvatarModal = () => {
  useVAD();    // solo una l√≠nea
  ‚Ä¶
}


	3.	Eliminar VoiceControls, VoiceRecorder y botones manuales.
	4.	Borrar time-outs de grabaci√≥n en useRecorder.
	5.	Verificar en logs:
	‚Ä¢	Solo un üé§ Starting voice activity detection... al abrir el modal.
	‚Ä¢	Transici√≥n phase: talking ‚Üí listening y luego speech-start / speech-end sin ‚Äútimeout reached‚Äù.

‚∏ª

7. Par√°metros recomendados de VAD

Par√°metro	Valor	Motivo
speechStartDelay	120 ms	Detecta frases cortas ‚Äúhola‚Äù sin lag
speechEndDelay	350 ms	Corta silencios > ‚Öì s para respuesta √°gil
cooldownDelay	250 ms	Evita rebotes en silencios muy breves
energyThreshold	0.01	Ajusta seg√∫n tu micro; menos = m√°s sensible


‚∏ª

Resultado esperado
	1.	No hay bot√≥n de micr√≥fono: la UI queda limpia.
	2.	Al terminar de hablar el avatar, el VAD entra instant√°neamente en modo escucha.
	3.	El usuario habla; VAD dispara speech-start ‚Üí recorder.start().
	4.	Cuando el usuario hace pausa, VAD dispara speech-end ‚Üí recorder.stop() sin time-out manual.
	5.	No existen logs duplicados de inicializaci√≥n VAD.

Con esto eliminas los conflictos y garantizas un loop conversacional 100 % manos libres, listo para tiempos de ciclo < 1000 ms. Dale duro y me cuentas c√≥mo va. üëäüèº